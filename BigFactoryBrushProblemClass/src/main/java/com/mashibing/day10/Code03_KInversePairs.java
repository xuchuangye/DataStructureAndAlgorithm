package com.mashibing.day10;

/**
 * 题目三：
 * 给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数
 * 逆序对的定义如下：对于数组的第i个和第j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对，否则不是
 * 由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值
 * <p>
 * 解题思路：
 * 1.数据范围：
 * n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
 * 2.时间复杂度：O(N * K)
 * 动态规划的样本对应尝试模型
 * 3.dp[i][j]表示在i, 2, 3, ..., i的范围内的数字进行排列，逆序对正好j个的排列有多少个
 * 4.使用具体例子去分析
 * 情况一：当j < i时
 * 假设dp[5][3]。那么所有的可能性：
 * 假设其余1,2,3,4使用a,b,c,d表示
 * 可能性1：5在倒数第一个位置，那么其余4个数形成3个逆序对，abcd5，使用 dp[4][3]表示
 * 可能性2：5在倒数第二个位置，那么其余4个数形成2个逆序对，abc5d，使用 dp[4][2]表示
 * 可能性3：5在倒数第三个位置，那么其余4个数形成1个逆序对，ab5cd，使用 dp[4][1]表示
 * 可能性4：5在倒数第四个位置，那么其余4个数形成0个逆序对，a5bcd，使用 dp[4][0]表示
 * 5不可能在a前面，因为5abcd的逆序对个数为4个，超过3了
 * 最后，将所有的可能性累加
 * <p>
 * 情况二：当 j >= i时
 * 假设dp[5][7]。那么所有的可能性：
 * 假设其余1,2,3,4使用a,b,c,d表示
 * 可能性1：5在倒数第一个位置，那么其余4个数形成7个逆序对，abcd5，使用 dp[4][7]表示
 * 可能性2：5在倒数第二个位置，那么其余4个数形成6个逆序对，abc5d，使用 dp[4][6]表示
 * 可能性3：5在倒数第三个位置，那么其余4个数形成5个逆序对，ab5cd，使用 dp[4][5]表示
 * 可能性4：5在倒数第四个位置，那么其余4个数形成4个逆序对，a5bcd，使用 dp[4][4]表示
 * 可能性5：5在倒数第五个位置，那么其余4个数形成3个逆序对，5abcd，使用 dp[4][3]表示
 * 当j >= i时，j最后不一定为0
 * 最后，将所有的可能性累加
 * 5.根据动态规划的样本对应尝试模型的规律，往往规律和可能性的划分与结尾有关
 * 6.动态规划的优化，斜率优化
 * 情况一：当 j < i时
 * dp[5][3] = dp[4][3] + dp[4][2] + dp[4][1] + dp[4][0]
 * dp[5][4] = dp[4][4] + dp[4][3] + dp[4][2] + dp[4][1] + dp[4][0]
 * 所以：dp[5][4] = dp[4][4] + dp[5][3]
 * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
 * 情况二：当 j >= i时
 * dp[5][7] = dp[4][7] + dp[4][6] + dp[4][5] + dp[4][4] + dp[4][3]
 * dp[5][8] = dp[4][8] + dp[4][7] + dp[4][6] + dp[4][5] + dp[4][4]
 * 所以：dp[5][8] = dp[4][8] + dp[5][7] - dp[4][3]
 * dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i]
 * <p>
 * Leetcode测试链接：
 * https://leetcode.cn/problems/k-inverse-pairs-array/
 *
 * @author xcy
 * @date 2022/7/27 - 15:23
 */
public class Code03_KInversePairs {
	public static void main(String[] args) {

	}

	/**
	 * -  0 1 2 3 4 5 6   -> k
	 * -1 1 0 0 0 0 0 0
	 * -2 1
	 * -3 1
	 * -4 1
	 * -5 1
	 * n
	 * dp[i][j]表示在i, 2, 3, ..., i的范围内的数字进行排列，逆序对正好j个的排列有多少个
	 * dp[1][0] = 1，只有1自己，形成逆序对的个数为0的排列为有1个，[1]
	 * dp[1][1, 2, ...] = 0，只有1自己，形成逆序对的个数为1,2,3, ...的排列有0个
	 * dp[2][0] = 1，只有1和2，形成逆序对的个数为0的排列有1个，[1, 2]
	 * dp[3][0] = 1，只有1和2,3，形成逆序对的个数为0的排列为1个，[1, 2, 3]
	 * <p>
	 * 中间的dp[i][j]位置依赖分析：使用具体例子去分析
	 * 情况一：当j < i时
	 * 假设dp[5][3]。那么所有的可能性：
	 * 假设其余1,2,3,4使用a,b,c,d表示
	 * 可能性1：5在倒数第一个位置，那么其余4个数形成3个逆序对，abcd5，使用 dp[4][3]表示
	 * 可能性2：5在倒数第二个位置，那么其余4个数形成2个逆序对，abc5d，使用 dp[4][2]表示
	 * 可能性3：5在倒数第三个位置，那么其余4个数形成1个逆序对，ab5cd，使用 dp[4][1]表示
	 * 可能性4：5在倒数第四个位置，那么其余4个数形成0个逆序对，a5bcd，使用 dp[4][0]表示
	 * 5不可能在a前面，因为5abcd的逆序对个数为4个，超过3了
	 * 最后，将所有的可能性累加
	 * <p>
	 * 情况二：当 j >= i时
	 * 假设dp[5][7]。那么所有的可能性：
	 * 假设其余1,2,3,4使用a,b,c,d表示
	 * 可能性1：5在倒数第一个位置，那么其余4个数形成7个逆序对，abcd5，使用 dp[4][7]表示
	 * 可能性2：5在倒数第二个位置，那么其余4个数形成6个逆序对，abc5d，使用 dp[4][6]表示
	 * 可能性3：5在倒数第三个位置，那么其余4个数形成5个逆序对，ab5cd，使用 dp[4][5]表示
	 * 可能性4：5在倒数第四个位置，那么其余4个数形成4个逆序对，a5bcd，使用 dp[4][4]表示
	 * 可能性5：5在倒数第五个位置，那么其余4个数形成3个逆序对，5abcd，使用 dp[4][3]表示
	 * 当j >= i时，j最后不一定为0
	 * 最后，将所有的可能性累加
	 * <p>
	 * 动态规划的优化，斜率优化
	 * 情况一：当 j < i时
	 * dp[5][3] = dp[4][3] + dp[4][2] + dp[4][1] + dp[4][0]
	 * dp[5][4] = dp[4][4] + dp[4][3] + dp[4][2] + dp[4][1] + dp[4][0]
	 * 所以：dp[5][4] = dp[4][4] + dp[5][3]
	 * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
	 * 情况二：当 j >= i时
	 * dp[5][7] = dp[4][7] + dp[4][6] + dp[4][5] + dp[4][4] + dp[4][3]
	 * dp[5][8] = dp[4][8] + dp[4][7] + dp[4][6] + dp[4][5] + dp[4][4]
	 * 所以：dp[5][8] = dp[4][8] + dp[5][7] - dp[4][3]
	 * <p>
	 * dp[7][9] = dp[6][9, 8, 7, 6, 5, 4, 3]
	 * dp[7][10] = dp[6][10, 9, 8, 7, 6, 5, 4]
	 * dp[7][10] = dp[6][10] + dp[7][9] - dp[6][3]
	 * <p>
	 * dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i]
	 *
	 * @param n 1 ... n范围内的数字
	 * @param k k个逆序对
	 * @return 返回1 ... n范围内的数字，形成k个逆序对的排列方式有多少个
	 */
	public int kInversePairs(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		int[][] dp = new int[n + 1][k + 1];
		dp[0][0] = 1;
		//代码优化之前
		/*for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
		}
		for (int j = 1; j <= k; j++) {
			dp[0][j] = 0;
		}*/

		//代码优化之后
		for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
			for (int j = 1; j <= k; j++) {
				/*
				//代码优化之前
				if (j >= i) {
					dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i];
				} else {
					dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
				}*/
				//代码优化之后
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
				if (j >= i) {
					dp[i][j] -= dp[i - 1][j - i];
				}
			}
		}
		return dp[n][k];
	}

	/**
	 * 因为方法数的答案可能会溢出，所以每次求dp[][]值的时候都mod一个值，LeetCode题目要求
	 *
	 * @param n 1 ... n范围内的数字
	 * @param k k个逆序对
	 * @return 返回1 ... n范围内的数字，形成k个逆序对的排列方式有多少个
	 */
	public int kInversePairs2(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		int[][] dp = new int[n + 1][k + 1];

		dp[0][0] = 1;
		for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
		}
		for (int j = 1; j <= k; j++) {
			dp[0][j] = 0;
		}

		int mod = 1000000007;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= k; j++) {
				dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
				if (j >= i) {
					//dp[i][j] - dp[i - 1][j - i]可能会出现负数，因为这个差值mod完之后，无法判断大小关系
					//举例：
					//3 - 5 = -2，-2 % mod = -2
					//为了避免这种情况，使用一种技巧：
					//(3 + mod - 5) % mod就不会出现这种情况了
					dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
				}
			}
		}
		return dp[n][k];
	}
}
