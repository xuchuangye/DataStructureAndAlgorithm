package com.mashibing.day14;

/**
 * 题目一：
 * 给你一个未排序的整数数组nums，请你找出其中没有出现的最小的正整数。
 * 请你实现时间复杂度为O(N)，额外空间复杂度为O(1)的解决方案。
 * 1 <= nums.length <= 5 * 10的5次方
 * -2的31次方 <= nums[i] <= 2的31次方 - 1
 * 题目二：字节跳动面试题：
 * 给你一个未排序的整数数组nums，给定一个正整数K，请你找出其中大于K并且没有出现的最小的正整数。
 * <p>
 * 题目一解题思路：
 * 1.时间复杂度：O(N)
 * 2.额外空间复杂度为O(1)，那么不能使用HashMap
 * 3.让nums[]元素的值尽可能和元素的索引有关，比如元素的索引为0，那么元素的值尽量是1，
 * 争取每一个元素，也就是i位置的索引上放i + 1的值，如果哪个位置上做不到，那么该位置上就是没有出现的最小的正整数
 * 题目二解题思路：
 * 首先将nums[]中所有的元素都减去K，然后通过题目一求出nums[]中没有出现的最小的正整数，就是题目二的解法
 * <p>
 * LeetCode测试链接：https://leetcode.com/problems/first-missing-positive/
 *
 * @author xcy
 * @date 2022/8/2 - 17:00
 */
public class Code06_MissingNumber {
	public static void main(String[] args) {

	}

	/**
	 * 具体分析：
	 * 1.设置有效区和垃圾区
	 * 有效区] [         ] [垃圾区
	 * 在有效区范围内，每一个i位置上放的值都是i + 1，并且设置L，L指向当前正在盯着的数字，那么L-1就是有效区的右边界
	 * 不再需要的数字进入垃圾区，并且设置R，R一方面表示垃圾区的左边界，另一方面表示最好的逾期，
	 * 什么是最好的逾期，就是收集的数字能够让返回的结果尽量大
	 * 举例：
	 * nums[] = {1, 2, 3, 4, 5, 6}
	 * index =   0, 1, 2, 3, 4, 5
	 * 最好的逾期，1 ~ 6的数字都收集一次，而且一个数字也不缺，尽量返回数字7是最好的逾期结果
	 * nums[] = 有效区]{-3,             ?}[垃圾区
	 * index =          0  1  2  3  4  5
	 * -                L                 R
	 * 因为题目要求返回最小的正整数，而-3不需要，所以将-3这个数字和5位置上的?进行交换，然后R往左扩，将-3放入垃圾区，
	 * 最好的逾期，1 ~ 5的数字都收集一次，而且一个数字也不缺，尽量返回数字6是最好的逾期
	 * 此时R == 5， R + 1 == 6，并且R + 1也是最好的逾期结果
	 * nums[] = 有效区]{6,          ? [-3}垃圾区
	 * index =         0  1  2  3  4   5
	 * -               L               R
	 * 如果? == 6，而最好逾期结果是1 ~ 5，因此6不需要，所以将6这个数字和4位置上的?进行交换，然后R往左扩，将6放入垃圾区
	 * 最好的逾期，1 ~ 4的数字都收集一次，而且一个数字也不缺，尽量返回数字5是最好的逾期
	 * 此时R == 4， R + 1 == 5，并且R + 1也是最好的逾期结果
	 * nums[] = 有效区]{?,         [6 -3}垃圾区
	 * index =         0  1  2  3  4  5
	 * -               L           R
	 * <p>
	 * 总结方法：
	 * nums[] = 1, 2, 3, 4, ... ,16, 17 ] ?     23    [31
	 * index =  0  1  2  3       15  16   L     22    R
	 * ?在什么情况下不需要，将其放入垃圾区
	 * (1)? <= nums[L]，因为1 ~ 17的数字以及收集过一次了，之后再出现一次都是垃圾
	 * (2)? > nums[R]，因为需要的是18 ~ 31的数字，超过范围也不需要
	 * (3)? - 1 == ?，此时的? == 23，而22位置上已经是23了，重复出现也不需要
	 * ?在什么情况下需要，将其放入有效区
	 * 此时的? != 23，那么L位置的?和22位置上的23进行交换，重复在L位置上盯着?
	 *
	 * @param arr 未排序的原始
	 * @return
	 */
	public static int firstMissingPositive(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		//有效区的右边界的下一个位置
		//0 ~ L - 1
		int L = 0;
		//垃圾区的左边界
		int R = arr.length;
		while (L != R) {
			//情况1：有效区往右扩
			//arr[L] = L + 1
			if (arr[L] == L + 1) {
				L++;
			}
			//情况2：垃圾区往左扩
			//? <= L || ? > R || [? - 1] = ?
			//nums[] = 1, 2, 3, 4, ... ,16, 17 ] ?     23    [31
			//index =  0  1  2  3       15  16   L     22    R
			//?在什么情况下不需要，将其放入垃圾区
			//(1)? <= nums[L]，因为1 ~ 17的数字以及收集过一次了，之后再出现一次都是垃圾
			//(2)? > nums[R]，因为需要的是18 ~ 31的数字，超过范围也不需要
			//(3)? - 1 == ?，此时的? == 23，而22位置上已经是23了，重复出现也不需要
			//?在什么情况下需要，将其放入有效区
			//此时的? != 23，那么L位置的?和22位置上的23进行交换，重复在L位置上盯着?
			else if (arr[L] <= L || arr[L] > R || arr[arr[L] - 1] == arr[L]) {
				//有效区的下一个位置的值和垃圾区的前一个位置的值进行交换
				swap(arr, L, R - 1);
				//垃圾区往左扩
				R--;
			}
			//情况3：
			//L < arr[L] <= R
			else {
				//有效区的下一个位置的值和该值本来应该出现的位置的值进行交换
				swap(arr, L, arr[L] - 1);
				//有效区不动
			}
		}
		//最后剩下的必然是缺失的最小正整数，又因为是位置，所以该位置上的值是L + 1
		//arr[] = 1, 2, 3, 4, 5
		//index = 0  1  2  3  4
		//-                   L
		return L + 1;
	}

	/**
	 * 交换数组中的两个元素
	 *
	 * @param arr 数组
	 * @param i   i位置
	 * @param j   j位置
	 */
	public static void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
