package com.mashibing.day14;

/**
 * 给定一个只由左括号和右括号的字符串，返回最长的有效括号子串的长度
 * <p>
 * 解题思路：
 * 1.以某个位置结尾能够往左推多长
 * i位置为"("，以i位置结尾能够往左推的长度为0
 * i位置为")"，查看i - 1位置能够往左推多长，如果i - 1位置为")"，那么i位置结尾能够往左推的长度为0
 * 如果i - 1位置为"("，那么以i位置结尾能够往左推的长度[至少]为i - 1位置能够往左推的长度 + 2
 * 此时继续来到k的位置，查看是否与i位置的")"能够进行匹配
 * 如果k位置为"("，那么以i位置结尾能够往左推的长度就止步在2了
 * 如果k位置为")"，并且知道以k - 1位置结尾能够往左推的长度即可，因为之前的位置已经统计过了，直接相加即可
 * 举例：
 * k i-1 i
 * ( ) ( ( ) )  (  )
 * 0 1 2 3 4 5  6  7
 * 0 2 0 0 2 6  0  8
 * 此时i == 7，i位置是")"，以i - 1位置结尾够往左推的长度为0，并且i - 1位置为"("，此时以i位置结尾能够往左推的长度至少
 * 为2，k == 5， 以k位置结尾能够往左推的长度为6，那么最终以i位置结尾能够往左推的长度是6 + 2 == 8
 *
 * @author xcy
 * @date 2022/8/2 - 16:59
 */
public class Code01_Parentheses {
	public static void main(String[] args) {

	}

	public static int maxLength(String s) {
		if (s == null || s.length() < 2) {
			return 0;
		}
		char[] str = s.toCharArray();
		int[] dp = new int[str.length];
		//dp[0] = 0;
		int ans = 0;
		int pre = 0;
		for (int i = 0; i < str.length; i++) {
			//如果str[i] != ')'，dp[i] == 0
			//如果str[i] == ')'，才参与以i位置结尾往左推的最远距离的计算
			if (str[i] == ')') {
				//与i进行配对的之前的位置
				//情况1：
				// ?   (  )  (  (  )  )  (  )   )
				//pre 10 11 12 13 14 15 16 17  i=18
				//此时i位置 == 18，并且以i - 1位置结尾往左能够推的最远距离dp[i - 1] == 8
				//那么与i进行配对的位置就是18 - 8 - 1 = 9，也就是i - dp[i - 1] - 1
				//情况2：
				// ?   )
				//pre i=18
				//此时i位置 == 18，并且以i - 1位置结尾往左能够推的最远距离dp[i - 1] == 0
				//那么与i进行配对的位置就是18 - 0 - 1 = 17，也就是i - dp[i - 1] - 1
				pre = i - dp[i - 1] - 1;
				//pre >= 0表示不能越界
				// ?  ( ) ( ) )
				//    0 1 2 3 4
				//pre         i
				//i == 4, dp[i - 1] == 4
				//pre = i - dp[i - 1] - 1 -> pre == -1
				//str[pre] == '('表示str[pre]必须是'('能够与')'进行配对
				// )  ( ) ( ) )
				// 5  6 7 8 9 10
				//pre         i
				//i == 10, dp[i - 1] == 4
				//pre = i - dp[i - 1] - 1 -> pre == 5
				//但是str[pre] != '('，不能与i位置的')'进行配对
				if (pre >= 0 && str[pre] == '(') {
					//以i位置结尾往左推的最远距离至少是 = 以i - 1位置结尾往左推的最远距离dp[i - 1] + 2
					//pre > 0 ? dp[pre - 1] : 0表示如果str[pre] == '('，那么还需要查看以pre - 1位置结尾
					//往左推的最远距离，如果pre - 1没有越界，那么就是dp[pre - 1]，否则就是0
					dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0);
				}
			}
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}
}
