### IndexTree

#### IndexTree的特点

1）支持区间查询 2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构 3）只支持单点更新

#### IndexTree的规律

1、help[] index位置上的值都包含哪些位置的值 假设index = 10111000 将最后一位1拆开，10110000，然后加1就是第一个数，10110001 ~ 10111000的 范围就是index包含哪些范围的值

举例： arr = []
索引 = 1, 2, 3, 4, 5, 6, 7, 8 -->    8的二进制： 00001000 将最后一个1抹去 所以8位置的值包含哪些范围的值：00000001 ~ 00001000 --> 1 ~ 8

索引 = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 -->   12的二进制： 00001100 将最后一个1抹去 所以12位置的值包含哪些范围的值：00001001 ~ 00001100 --> 9 ~
12

索引 = 1, 2, 3, ... 29 -->  29的二进制： 00011101 将最后一个1抹去 所以29位置的值包含哪些范围的值：00011101 ~ 00011101 --> 29 ~ 29

2、arr[] 1 ~ i位置的累加和 -->  版本1 1 ~ i位置的累加和 = 将i的二进制最后一个1拆开的索引的累加和 + i位置自己的累加和

举例： arr = []
求索引 1 ~ 33的累加和 = help[]将33的二进制的最后一个1拆开的索引的累加和 + help[]33自己的累加和

33的二进制：00100001 arr[] 1 ~ 33的累加和 = help[]00100000索引的累加和 + help[]00100001索引的累加和

3、arr[] 1 ~ i位置的累加和 -->  版本2 原数组arr[] 1 ~ i位置的累加和 = help[]i位置自己的累加和 + help[]将i的二进制最后一个1去除的索引的累加和

+ help[]将i的二进制倒数第二个1去除的索引的累加和 + help[]将i的二进制倒数第三个1去除的索引的累加和
+ ... 直到i的二进制的所有1都去除

举例： 原数组arr[]索引 1 ~ 358的累加和 = help[]358位置自己的累加和 + help[]将358的二进制的最后一个1去除的索引的累加和

+ help[]将358的二进制倒数第二个1去除的索引的累加和 + help[]将358的二进制倒数第三个1去除的索引的累加和
+ ... 直到358的二进制的所有1都去除

358的二进制： 0101100110 原数组arr[]索引1 ~ 358的累加和 = help[]0101100110索引的累加和 + help[]0101100100索引的累加和

+ help[]0101100000索引的累加和 + help[]0101000000索引的累加和 + help[]0100000000索引的累加和

证明： help[]0101100110索引的累加和 = arr[](0101100100 + 1)索引的累加和 ~ arr[]0101100110索引的累加和 help[]0101100100索引的累加和 = arr[](
0101100000 + 1)索引的累加和 ~ arr[]0101100100索引的累加和 help[]0101100000索引的累加和 = arr[](0101000000 + 1)索引的累加和 ~ arr[]
0101100000索引的累加和 help[]0101000000索引的累加和 = arr[](0100000000 + 1)索引的累加和 ~ arr[]0101000000索引的累加和 help[]0100000000索引的累加和 =
arr[](0000000000 + 1)索引的累加和 ~ arr[]0100000000索引的累加和

arr[] 1 ~ 358的累加和 = help[]0101100110索引的累加和

+ help[]0101100100索引的累加和
+ help[]0101100000索引的累加和
+ help[]0101000000索引的累加和
+ help[]0100000000索引的累加和
+ help[]0000000000索引的累加和

4、修改arr[] i位置的值，跟每次i的二进制最后一个1加1的位置的值有关 举例： arr[] 索引 = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
假设6位置上的值被修改了，那么受牵连的索引有6位置，8位置，16位置...

6的二级制：00000110 第一个受牵连的索引：最后一个1加1的二进制：00001000 -> 8 第二个受牵连的索引：最后一个1加1的二进制：00010000 -> 16 ...直到越界为止

所以如果6位置上的值加上指定的值num 那么8位置上的值也加上num 那么16位置上的值也加上num ...直到越界为止

5、IndexTree从一维到二维
arr[1 - i]行[1 - j]列范围的累加和 对应 help[i][j]的值
int[][] arr = {
		//    1  2  3  4  5
		/*1*/{N, N, N, N, N},
		/*2*/{N, N, N, N, N},
		/*3*/{N, N, N, N, N},
		/*4*/{N, N, N, N, N},
		/*5*/{N, N, N, N, N},
};
int[][] help = {
		//    1  2  3  4  5
		/*1*/{N, N, N, N, N},
		/*2*/{N, N, N, N, N},
		/*3*/{N, N, N, N, N},
		/*4*/{N, N, N, N, N},
		/*5*/{N, N, N, N, N},
};

更新arr[i][j]的值：
那么在help[]中受影响的行数范围：从i的二进制去除最后一个1加+1 到 i的二进制自己
那么在help[]中受影响的列数范围：从j的二进制去除最后一个1加+1 到 j的二进制自己

举例：
更新arr[56][52]的值：
i的二进制：00111000 
j的二进制：00110100
那么在help[]中受影响的行数范围：从 i的二进制去除最后一个1加+1 (00110001) 到 i的二进制自己 (00111000)
那么在help[]中受影响的列数范围：从 j的二进制去除最后一个1加+1 (00110001) 到 j的二进制自己 (00110100)

6、IndexTree从一维到三维和从一维到二维的情况一样
7、IndexTree返回指定左上角到右下角区域的累加和



#### IndexTree 和 SegmentTree的相同点和不同点

1.相同点： 1)IndexTree能够解决单点位置的值更新，SegmentTree也能够解决单点位置的值更新，update(L, R, num)中 L == R的情况

2.不同点： 1)IndexTree能够解决单点位置的值更新，不能解决指定L-R范围上更新成一个值 SegmentTree能够解决指定范围位置的值更新 2)IndexTree从一维到二维非常简单，SegmentTree从一维到二维非常麻烦
