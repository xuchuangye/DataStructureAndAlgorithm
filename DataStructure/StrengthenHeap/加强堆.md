
### 堆结构

#### 优先级队列底层实现就是堆结构

```java
import java.util.PriorityQueue;

public class HeapDemo {
	public static void main(String[] args) {
		PriorityQueue<Integer> heap = new PriorityQueue<>();
	}
}
```
### 完全二叉树

#### 节点之间的关系表达式
i表示当前节点的权值，
当前节点的左子节点的权值是 2 * i + 1
当前节点的右子节点的权值是 2 * i + 2
当前节点的父节点的权值是 (i - 1) / 2，向下取整

### 大根堆
大根堆是描述子节点和父节点之间谁的权值大的关系，不是描述两个子节点之间的大小关系

在完全二叉树中，每一棵子树的头节点的权值在当前整棵子树都是最大的，叫做大根堆
### 小根堆
小根堆是描述子节点和父节点之间谁的权值小的关系，不是描述两个子节点之间的大小关系

在完全二叉树中，每一棵子树的头节点的权值在当前整棵子树都是最小的，叫做小根堆


### 结论

#### 面试刷题时，指令条数不超过10^8次方到10^9次方
刷题时，C / C++指令条数 10^8次方 ~ 10^9次方以内 1-2秒
Java指令条数 10^8次方 ~ 10^9次方以内 2-4秒
举例：数据量N = 10²，而指令条数为10^8次方,
那么推算出算法的时间复杂度为O(N³)就一定能通过

#### 面试刷题时，一定是单线程的，单CPU，单内存系统


### 手动改写堆（非常重要）
为什么要手动改写堆？
系统提供的堆无法做到的事情
1、已经入堆的元素，如果参与排序的方式变化，系统提供的堆无法做到时间复杂度O(logN)的调整！都是O(N)的调整！
2、系统提供的堆只能弹出堆顶元素，无法删除堆中的任意一个元素，或者说：无法在时间复杂度O(logN)内完成！一定会高于O(logN)
根本原因：系统堆没有反向索引表
T类型一定是自定义引用类型
#### 系统提供的堆无法做到的事情
1、已经入堆的元素，如果参与排序的指标方法变化，系统提供的堆无法做到时间复杂度
O(logN)的调整！都是O(N)的调整！
2、系统提供的堆只能弹出堆顶元素，无法删除堆中的任意一个元素，或者说：无法在时间
复杂度O(logN)内完成！一定会高于O(logN)
根本原因：无反向索引表
