### 有序表

#### 有序表的思想和数据库的索引
为什么可以建索引：
被索引的字段是可排序的
任何字符串都可以排序
任何建索引的字段都是可以排序的，因为天然具备排序的属性

排序是如何加速查找数据库的数据的


#### 有序表的原理
数据库中的数据底层写在硬盘上是顺序的，但是在之上创建一颗有序树(搜索二叉树)
举例：
数据库的数据表
A, 17
Z, 25
K, 19
G, 23
数据底层之上创建有序树(搜索二叉树)
  G
 / \
A   Z
 \
  K
G：第4行
A：第1行
K：第3行
Z：第2行
搜索二叉树的性质：当前节点的左子节点值比当前节点的值小，当前节点的右子节点值比当前节点的值大
如果要查找A，从G节点开始查找，A的值比G小，所以从G节点的左边开始查找，找到A节点所在的数据在物理表中的第1行，马上将第1行记录取出来
#### 有序表的设计
有序表(接口名) --> 技术标准/规范

AVL树、SB树、红黑树、234树、跳表、B树、B+树(实现类)
具体的细节不同，但是有序表该有的功能，实现类都能做到，有序表要求的性能，实现类的这些树时间复杂度：O(logN)

##### 搜索二叉树的组织问题
搜索二叉树本身就支持索引，增删改查都可以在树上操作，只要搜索二叉树的规则不变，是非常简单的
但是如果出现用户输入的数据导致搜索二叉树的某一侧的深度过大，就又类似于链表的结构，查找效率非常的差
此时就需要平衡搜索二叉树的左旋和右旋操作来保证树的两侧深度基本平衡，深度差值不超过1

为什么不使用哈希表的，时间复杂度：O(1)不是更好吗？
1.哈希表只适合等值查询，查询效率高不适合范围查询，因为哈希表底层数据是通过哈希函数计算出哈希值进行存储的，所以哈希表中的数据都是无序的
范围查询的时候需要依次进行遍历操作，比较浪费时间
2.哈希表在使用的时候，必须都加载到内存中，比较消耗内存空间

搜索二叉树添加节点

搜索二叉树删除节点
1.当前节点既没有左子节点，也没有右子节点，直接删除
2.当前节点有左子节点，没有右子节点，直接让当前节点的左子节点替代当前节点
3.当前节点有右子节点，没有左子节点，直接让当前节点的右子节点替代当前节点
4.当前节点既有左子节点，又有右子节点，既可以将当前节点的右子节点的最左子节点替换当前节点，也可以将当前节点的左子节点的最右子节点
替换当前节点

证明：
当前节点的左子节点的最右子节点是离当前节点最近并且比当前节点小的值
当前节点的右子节点的最左子节点是离当前节点最近并且比当前节点大的值

##### 二叉树的左旋和右旋：
1.不会破坏搜索二叉树的性质
2.变平衡的最基本操作只有左旋和右旋

##### 二叉树的规律
1.AVL树、SB树、跳表、红黑树、234树、B树、B+树等等，时间复杂度都是：O(logN)
1)AVL树的平衡性非常敏感
2)SB树的删除节点不需要进行平衡性调整
3)红黑树优化了常数时间
4)跳表：随机
虽然数据库使用B树、B+树常数时间比AVL树好，但是时间复杂度都是O:(logN)
2.只有平衡性规则不一样


#### 为什么传统关系型数据库会陷入没落
水平扩展数据库、一致性哈希数据库
因为关系型数据库的底层有序表结构拆分不是，IO问题解决不了，MySQL数据库、Oracle数据库等一定都是单例，一定都在一台机器上，
一定升级只能使用大型机，
#### 积压结构
举例：
ArrayList，每次添加元素时，如果已经满了，长度就会扩充一倍

AVL树平衡性比较敏感，不适合用于硬盘上，因为磁盘IO的限制
红黑树、234树、B树、B+树这种积压结构，非常适合用于硬盘上，因为平衡性比较模糊，很长时间都不需要调整平衡性，如果真的
不平衡了，集体IO一次就完了

随着材料科学的进步，假设硬盘IO和计算机的CPU计算一样快，这些积压结构也会走向没落


#### 水平扩展的数据库，知识分布式存储数据库会逐渐占据主流