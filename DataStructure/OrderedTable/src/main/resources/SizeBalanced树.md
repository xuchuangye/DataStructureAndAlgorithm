### SizeBalanced树

#### SizeBalanced树的平衡因素
节点的个数size

#### SizeBalanced树的四种不平衡的类型
类型1.LL
    A
   / \
  B   C
 /   
D
C节点作为D节点的叔叔节点，D节点这个侄子节点的子树节点个数大于C节点这个叔叔节点的子树节点个数时，会破坏平衡性

  B
 / \
D   A
     \
      C
平衡性调整：
除了整棵树进行右旋，还要递归调用maintain(A)、递归调用maintain(B)，重复查询有没有违规

为什么要进行递归调用，因为不清楚A节点的左子树中节点的子树节点个数是否大于C节点的子树节点个数
类型2.LR
  A
 / \
B   C
 \
  D
C节点作为D节点的叔叔节点，D节点这个侄子节点的子树节点个数大于C节点这个叔叔节点的子树节点个数时，会破坏平衡性
类型3.RR
  A
 / \
B   C
     \
      D
B节点作为D节点的叔叔节点，D节点这个侄子节点的子树节点个数大于B节点这个叔叔节点的子树节点个数时，会破坏平衡性
    C
   / \
  A   D
 /
B
平衡性调整：
除了整棵树进行右旋，还要递归调用maintain(A)、递归调用maintain(C)，重复查询有没有违规
因为B节点的子树不变，D节点的子树不变，所以这两个节点不需要递归
类型4.RL
  A
 / \
B   C
   /
  D
B节点作为D节点的叔叔节点，D节点这个侄子节点的子树节点个数大于B节点这个叔叔节点的子树节点个数时，会破坏平衡性

#### SizeBalanced树添加节点
和AVL树一样，添加一个节点时，沿途所有节点都调用maintain()
整个过程不是从上往下的，是由添加的节点开始，受影响的每一个节点都调用maintain()一遍

#### SizeBalanced树删除节点
和AVL树一样，删除一个节点时，沿途所有节点都调用maintain()
整个过程不是从上往下的，是由删除的节点开始，受影响的每一个节点都调用maintain()一遍

#### SizeBalanced树和AVL树调整平衡性的区别

AVL树平衡性非常的敏感，AVL是一颗特别敏感的树，添加节点和删除节点都会影响往上的平衡性调整
效果就是：不需要进行递归行为，只需要沿途的每一个节点该调整的使用有限几个变量就能调整

AVL在添加节点时，对每一个节点的调整就做有限几个动作，没有递归行为可以传递。
区别在于：AVL树做完动作就不再递归了，沿途节点查询平衡被破坏的类型和调整平衡性两个动作，没有后续的递归传递

SizeBalanced树只关注节点个数之间的关系，有可能很长时间都不需要进行调整，所以在进行调整的时候，调整动作和AVL树一样，
区别在于：查看哪一个当前节点的子节点变了，需要递归以当前节点为头节点的子树往下的动作让树变平衡的

需要调用递归过程的原因：在当前节点调整完之后，并不确定当前节点底层的是否还是具有平衡性的
严格的数学证明之后，时间复杂度：O(logN)，但是忽略掉

为什么时间复杂度不会因此上升呢？
因为均摊了，之前剩下来的动作即便是整棵树雪崩了，均摊下来时间复杂度还是O(logN)
之前攒了好多的事儿，只不过这次雪崩之后，做了而已

SizeBalanced树可以在删除节点时候不进行平衡性调整，只在添加节点的时候进行平衡性的调整
平衡性的调整是递归行为，哪怕删除节点时不调，添加节点时调，因为这棵树是递归行为，所以平衡性的调整会传递的，依然能够保证树的平衡

所以为什么建议SizeBalanced树去实现有序表，因为SizeBalanced树省去了删除时候的调整操作
虽然SizeBalanced树在删除节点的时候，可能会出现棒状结构，假设添加节点的个数为2的64次方，层数最多64层，删除节点之后的棒状结构
高度最高也就是64，一旦再次添加节点时，整棵树会迅速调整平衡，因为SizeBalanced数对每一个节点的查询平衡性都是递归行为，能够对所有
沿途节点查询平衡性，所以SizeBalanced树在删除节点的时候不需要进行平衡性的调整
