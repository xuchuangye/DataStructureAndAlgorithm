### Morris遍历

#### 二叉树遍历的时间复杂度和额外空间复杂度
时间复杂度：O(N) N表示二叉树的节点个数
额外空间复杂度：O(K) K表示二叉树的深度

#### Morris遍历的时间复杂度和额外空间复杂度
时间复杂度：O(N) N表示二叉树的节点个数
额外空间复杂度：O(1) 

#### Morris遍历的优化
Morris遍历的优化的不是递归遍历的时间，而是优化的是空间

#### Morris遍历的分析
1.Morris遍历是利用了什么来进行遍历的
1)Morris遍历是利用二叉树上大量指针空闲空间的方式进行遍历的
2)因为二叉树的叶子节点的左指针和右指针都占空间，并且没有使用
所以二叉树有大量的空闲空间没有使用，空间也就浪费了，Morris遍历正是利用了这棵树自带的没有利用起来的空闲空间帮助完成的遍历

2.Morris遍历是如何将递归遍历都需要使用的栈(不管是系统栈还是Stack)空间省掉的
1)Morris遍历是通过利用二叉树中大量空闲指针的方式，达到节省空间的目的

#### Morris遍历的细节
假设来到当前节点cur，开始时cur来到头节点位置
1)如果cur没有左子树，cur向右移动(cur = cur.right)
2)如果cur有左子树，找到左子树上最右的节点mostRight，查看mostRight的右指针指向：
- a.如果mostRight的右指针指向null，让其指向cur，然后cur向左移动(cur = cur.left)
- b.如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)
3)cur为空时遍历停止

#### Morris遍历序
任何节点只要有左子树，就会来到左子树两次
举例：
------a
-----/ \
----b   c
---/ \ / \
--d  e f  g
Morris遍历序：a, b, d, b, e, a, c, f, c, g
只要当前节点有左子树，该节点都会经过两次，并且第二次经过时，当前节点的左子树一定都遍历过

#### Morris遍历的实质
1.当前节点如果有左子树，那么就使用左子树的最右节点的右指针状态来标记到底是第一次经过当前节点，还是第二次经过当前节点
举例：
------a
-----/ \
----b   c 
---/ \ / \
--d  e f  g

如何知道是第一次经过a节点？
如果a节点左子树的最右节点e的右指针指向null，那么一定是第一次经过a节点，然后将e节点的右指针指向a节点
如果a节点左子树的最右节点e的右指针已经指向a节点，那么一定是第二次经过a节点
如何知道是第一次经过b节点？
如果b节点左子树的最右节点d的右指针指向null，那么一定是第一次经过b节点，然后将d节点的右指针指向b节点
如果b节点左子树的最右节点d的右指针已经指向b节点，那么一定是第二次经过b节点

2.Morris遍历在利用任何一个节点的左子树的最右节点的右指针向递归序致敬

3.建立一种机制：
对于没有左子树的节点只到达一次，
对于有左子树的节点会到达两次
morris遍历时间复杂度依然是O(N)


#### Morris遍历的实际应用
1.在内存比较吃紧的情况下，比如：嵌入式编程，系统编程
代码是要做系统的，所有人都要在系统上跑，越底层的要求越高效，越省空间

2.内存是固定的，系统占用空间多了，应用可占用的空间就少了
越底层的东西越要求高效，就越要求时间做到的情况下，空间占用也尽量的少
只是你觉得内存便宜不需要去关注，不代表其他程序员不关注，甚至可能很重要

3.手机系统也是一样的，系统占用空间越少，可安装的应用空间也就越多
阿波罗登月使用128k就做到了，怎么做到的，就是把所有空间使用到极致的结果

#### Morris遍历序实现先序遍历、中序遍历、后序遍历
举例：
------a
-----/ \
----b   c
---/ \ / \
--d  e f  g
Morris遍历序：a, b, d, b, e, a, c, f, c, g

1.Morris遍历序 -> 先序遍历：
对于能够经过两次的节点，在第一次经过的时候就打印；对于能够经过一次的节点，直接打印

先序遍历：第一次的a, 第一次的b, d, e, 第一次的c, f, g  -> a, b, d, e, c, f, g

2.Morris遍历序 -> 中序遍历：
对于能够回到自己两次的节点，在第二次经过的时候就打印；对于能够回到自己一次的节点，直接打印

中序遍历：d, 第二次回到自己的b, e,第二次回到自己的a, f, 第二次回到自己的c, g -> d, b, e, a, f, c, g

3.Morris遍历序 -> 后序遍历：
对于能够回到自己两次的节点，在第二次经过的时候，逆序打印左子树的右边界，最后逆序打印整棵树的右边界

后序遍历：第二次回到b节点，逆序打印b的左子树的右边界，d节点，第二次回到a节点，逆序打印a的左子树的右边界，e节点，b节点
第二次回到c节点，逆序打印c的左子树的右边界，f节点，最后逆序打印整棵树的右边界，g节点，c节点，a节点
d, e, b, f, g, c, a

#### 两个比较重要的技巧
1.二叉树的递归套路 --> 最优解的判断标准
题目需要信息的强整合，需要知道左子树的完整信息和右子树的完整信息才能知道整棵树以x为根节点的信息
2.Morris遍历 --> 最优解的判断标准
题目不需要信息的强整合，不需要知道左子树的完整信息和右子树的完整信息就能够知道整棵树以x为根节点的信息