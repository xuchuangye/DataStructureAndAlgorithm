## 排序

### 排序的分类

1、基于比较的排序 冒泡、插入、选择、 归并、快速、希尔、 堆 2、不基于比较的排序 计数、基数 3、不基于比较的排序，数据源范围一定特殊 4、不基于比较的排序适用范围没有基于比较的排序使用范围广

### 排序的稳定性

1、排序的稳定性是指同样大小的样本，排序之后不会改变相对次序 2、排序的稳定性对于基础类型来说，没有任何意义；对于引用类型来说，非常有意义 3、排序的稳定性对于商品的价格、销量、好评等用户需要购买的商品参考依据异常的重要

### 归并排序

#### 小和问题

在一个数组中，将每一个比当前数小的左边的数累加起来，叫做这个数组的小和。 求一个数组的小和。

##### 解题思路：实际上是记录右边比当前数大的数的个数，当前数乘以个数的积进行累加

1、使用归并排序将数组进行划分，划分为左边数组和右边数组 2、当右边数组中的数值比左边数组中的数值大时，记录右边数组中大于左边 数组中的数值个数，并且乘以左边数组中的数值得到的积，累加到小和中
3、当右边数组中的数值比左边数组中的数值小时，不记录 4、最终小和 = 左边数组的小和 + 右边数组的小和 + 左边数组和右边数组合并的小和

### 排序算法的总结

1、不基于比较的排序，对数据样本有严格要求，不易改写 2、基于比较的排序，规定好两个样本如何比较大小就可以直接复用 3、基于比较的排序，时间复杂度的极限是O(N * logN)
4、时间复杂度O(N * logN)，额外空间复杂度低于O(N)，并且具有稳定性，而且是基于比较的排序是不存在的 5、 1）为了绝对的速度选择快速排序，快速排序的常数时间最快 2）为了省空间选择堆排序， 3）为了稳定性选择归并排序，

### 排序算法常见的坑

1、归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是没有稳定性 --> 学术地位不重要 2、“原地归并排序”是垃圾帖，时间复杂度会变成O(N²)
3、快速排序稳定性改进，“01 stable sort”，但是会对数据样本要求更多 --> 直接使用桶排序、计数排序、基数排序

4、题目本身就很贱 题目：在整型数组中，请把奇数放在数组的左边，偶数放在数组的右边 要求： 1.所有奇数之间原始的相对次序不变，所有偶数之间原始的相对次序不变 2.时间复杂度O(N)，额外空间复杂度O(1)

为什么？因为快速排序可以将奇数划分到左边，偶数划分右边，还能做到相对次序不变，快速排序不知道优化？ 如何怼面试官？面试官你好，我也不知道该如何写，我都等了10年，求求你告诉我该如何解答？

### 工程上对排序的改进

#### 稳定性的考虑

系统实现的排序Arrays.sort()分为两种情况： 1、基础类型，快速排序的改进，因为稳定性对于基础类型来说不重要，所以使用没有稳定性的快速排序是再合适不过了
2、引用类型，系统不知道你需不需要稳定性，但系统先保证稳定性，所以使用具有稳定性的归并排序是再合适不过了

````java
public class Sorting {
	public static void main(String[] args) {
		Arrays.sort();
	}
}
````

#### 充分利用O(N * logN) 和 O(N²) 排序各自的优势

```java
public class SortTest {
	public static void main(String[] args) {
		int[] arr = {4,2,1,3,5};
        quickSort(arr);
	}

	public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}
    //样本数据量比较大时，使用快速排序
	public static void quickSort(int[] arr, int left, int right) {
		if (left + 60 > right) {
			//使用插入排序，因为样本数据量比较小时，比较有优势
		}
		int mid = left + (right - left) / 2;

		int[] equalArea = partition(arr, left, right);
		quickSort(arr, left, equalArea[0] - 1);
		quickSort(arr, equalArea[1] + 1, right);
	}

	public static int[] partition(int[] arr, int left, int right) {
		return new int[]{};
	}
}
```