### DC3算法
1.该算法是根据索引%3来进行分组，进而搞出来的算法
2.
#### 后缀数组
1.可以是字符串数组
String[] str = {"a","a","b","a","a","b","a","a"}
索引：            0   1   2   3   4   5   6   7
以索引7位置开头的后缀：a        -> 第0名
以索引6位置开头的后缀：aa       -> 第1名
以索引5位置开头的后缀：baa      -> 第6名
以索引4位置开头的后缀：abaa     -> 第4名
以索引3位置开头的后缀：aabaa    -> 第2名
以索引2位置开头的后缀：baabaa   -> 第7名
以索引1位置开头的后缀：abaabaa  -> 第5名
以索引0位置开头的后缀：aabaabaa -> 第3名
后缀数组 arr = { 7, 6, 3, 0, 4, 1, 5, 2 }
索引：           0  1  2  3  4  5  6  7

2.可以是数值数组
int[] array = {103, 67, 89, 100}
索引：           0   1   2   3
以索引3位置开头的后缀：100
以索引2位置开头的后缀：89, 100
以索引1位置开头的后缀：67, 89, 100
以索引0位置开头的后缀：103, 67, 89, 100
后缀数组 arr = {1, 2, 3, 0}
索引：          0  1  2  3
#### 暴力解生成后缀数组的时间复杂度
1.生成所有的后缀字符串，时间复杂度：O(N²)
2.N个字符串去排序，排序的代价是O(N * logN)，而且每次排序比较的代价是O(N)，所以时间复杂度：O(N * logN * N)
3.暴力解的时间复杂度O(N² * logN)

#### DC3算法生成后缀数组的时间复杂度
1.DC3算法生成后缀数组的时间复杂度O(N)

#### DC3算法生成后缀数组的过程
1.索引对3进行取模，分出3类
索引：[0 1 2 3 4 6 7 8 9 10 11]
0 % 3 = 0  -> S0
1 % 3 = 1  -> S1
2 % 3 = 2  -> S2
3 % 3 = 0  -> S0
4 % 3 = 1  -> S1
5 % 3 = 2  -> S2
6 % 3 = 0  -> S0
7 % 3 = 1  -> S1
8 % 3 = 2  -> S2
9 % 3 = 0  -> S0
10 % 3 = 1  -> S1
11 % 3 = 2  -> S2
所以S0类：0 3 6 9   S1类：1 4 7 10   S2类： 2 5 8 11
2.求出S1和S2类的排名
假设：String[] arr = {"a","a","b","a","b","a","a"}
索引：                 0   1   2   3   4   5   6
分类：                 S0  S1  S2  S0  S1  S2  S0
S1和S2类的排名：
以索引1位置开头的后缀：ababaa  ->第1名
以索引2位置开头的后缀：babaa   ->第3名
以索引4位置开头的后缀：baa     ->第2名
以索引5位置开头的后缀：aa      ->第0名
3.求出S0类的排名
S0类的排名：
以索引0位置开头的后缀："a" + 以索引1位置开头的后缀(第1名) -> 第1名
以索引3位置开头的后缀："a" + 以索引4位置开头的后缀(第2名) -> 第2名
以索引6位置开头的后缀："a" + 空白                      -> 第0名
4.合并S0和S1S2的排名
左 -> S0                      右 -> S1S2
  以索引6位置开头的后缀          以索引5位置开头的后缀
  以索引0位置开头的后缀        ->以索引1位置开头的后缀
->以索引3位置开头的后缀          以索引4位置开头的后缀
o                             以索引2位置开头的后缀
左指针 -> 和右指针 ->
第1步：
以索引6位置开头的后缀："a" + 空白
以索引5位置开头的后缀："a" + "a"
所以排第0名的是以索引6位置开头的后缀，左指针往下移
第2步：
以索引0位置开头的后缀："a" + "a" + 以索引2位置开头的后缀排名
以索引5位置开头的后缀："a" + "a" + 空白
所以排第1名的是以索引5位置开头的后缀，右指针往下移
第3步：
以索引0位置开头的后缀："a" + "a" + 以索引2位置开头的后缀排名
以索引1位置开头的后缀："a" + "b" + 以索引2位置开头的后缀排名
所以排第2名的是以索引0位置开头的后缀，左指针往下移
第4步：
以索引3位置开头的后缀："a" + "b" + 以索引5位置开头的后缀排名 -> 第0名
以索引1位置开头的后缀："a" + "b" + 以索引2位置开头的后缀排名 -> 第3名
所以排第3名的是以索引3位置开头的后缀，左指针不移动
第5步：
直接根据S1S2的排名，得出第4名以索引1位置开头的后缀，第5名以索引4位置开头的后缀，第6名以索引2位置开头的后缀
5.假设String arr = {"m", "i", "s", "s", "i", "s", "s", "i", "p", "p", "i"}
索引：               0    1    2    3    4    5    6    7    8    9    10
分出S1S2类，以及取出每某个索引位置开头的前三位后缀：
S1S2类的索引：1, 2, 4, 5, 7, 8, 10
以arr[]索引1位置开头的前三位后缀：iss  -> 第3名
以arr[]索引2位置开头的前三位后缀：ssi  -> 第5名
以arr[]索引4位置开头的前三位后缀：iss  -> 第3名
以arr[]索引5位置开头的前三位后缀：ssi  -> 第5名
以arr[]索引7位置开头的前三位后缀：ipp  -> 第2名
以arr[]索引8位置开头的前三位后缀：ppi  -> 第4名
以arr[]索引10位置开头的前三位后缀：i00 -> 第1名

注：S1放左边，S2放右边，是为了解决相同排名的问题，因为原始数组中已经出现了相同的排名

将S1放左边，S2放右边，合并之后生成新的数组 newArr = {}
S1类的索引：1  4  7  10，S2类的索引：2, 5, 8
排名：     3  3  2  1             5  5  4

原始索引： 1  4  7  10  2  5  8
newArr = {3, 3, 2, 1, 5, 5, 4}
索引：     0  1  2  3  4  5  6
第0名：以newArr[]索引3位置开头的后缀：1 + 5 + 5 + 4                -> 代表原始数组以索引10位置开头的后缀
第1名：以newArr[]索引2位置开头的后缀：2 + 1 + 5 + 5 + 4            -> 代表原始数组以索引7位置开头的后缀
第2名：以newArr[]索引1位置开头的后缀：3 + 2 + 1 + 5 + 5 + 4        -> 代表原始数组以索引4位置开头的后缀
第3名：以newArr[]索引0位置开头的后缀：3 + 3 + 2 + 1 + 5 + 5 + 4    -> 代表原始数组以索引1位置开头的后缀
第4名：以newArr[]索引6位置开头的后缀：4                            -> 代表原始数组以索引8位置开头的后缀
第5名：以newArr[]索引5位置开头的后缀：5 + 4                        -> 代表原始数组以索引5位置开头的后缀
第6名：以newArr[]索引4位置开头的后缀：5 + 5 + 4                    -> 代表原始数组以索引2位置开头的后缀


6.总结
DC3生成后缀数组的时间复杂度：
1).如果直接能够使用三维数据使用基数排序搞定
2).生成新的数组，长度为三分之二N，因为原始数组长度为N，分出3类，新的数组中包含两类，所以新的数组长度为三分之二N，
并且新的数组中的最大值是N，因为排名不可能超过N
3)总的时间复杂度：T(N) = T(三分之二N) + O(N)

#### DC3算法的拓展
1.如果字符串类型的数组(通过ASCII码得到int类型的数组)的值过大，使用DC3算法，时间复杂度中常数系会非常大，因为值越大，桶的空间也越大
所以可以使用对应法，进行离散化
如果数组中的值特别千差万别，做成比较窄的域，去调用DC3，可以节省常数时间
举例：
arr[] = {1000000, 5, 900000,1000000000}
将5 -> 1, 900000 -> 2, 1000000 -> 3, 1000000000 -> 4
等同于arr[] = {3, 1, 2, 4}

#### DC3算法的地位
1)暴力解  不通过
2)优化之后  通过70%
3)答案解  通过100%
4)DC3算法解  完虐3)  时间复杂度：O(N)    
5)倍增算法 时间复杂度：O(N * logN)

#### SA模板
1)SA[] -> Rank[]
2)SA[] -> Height[]
3)RQM问题
