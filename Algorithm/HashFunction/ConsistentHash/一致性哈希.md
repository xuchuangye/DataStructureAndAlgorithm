### 一致性哈希

哪一个key最后用哈希值确定分片的，这个key在业务上叫做hashkey，选择一个良好的hashkey是非常重要的

服务器就三台
如果hashkey选择良好，不同的hashkey就能均匀的分布在这三台服务器上
如果hashkey选择不当，可能会出现严重的问题，假设使用国家名(中国、美国)来做hashkey，虽然数据底层服务器会把所有的key都分发到
不同的服务器，但如果中国和美国的服务是特别多的，key虽然均分了，但实际上会导致总有一些服务器没有中国或者美国的归属那么频繁

虽然服务器的归属是不挑hashkey的，不同的key会均分，但如果业务上有高频，就也会导致负载不均

高频的key选择一部分，中频的key选择一部分，低频的key选择一部分，只能从业务上挖掘什么key适合做hashkey

如果三台服务器需要额外增加一台，或者出现故障减少一台，那么服务器中所有的key都需要重新计算，然后决定归属
数据迁移的代价是全量的，哪怕增加一台或者减少一台，都非常的难受

#### 一致性哈希解决的问题
一致性哈希解决的就是增加或者减少服务器，让数据迁移不是全量的，而且能够极大地减少数据迁移的代价以及提升数据迁移的效率，
还能够做到负载均衡和负载管理

1.在一致性哈希中，是没有取模的概念的
2.环上数据的归属：顺时针的第一台的服务器
3.如何保证机器上环不冲突？
1)当数据样本量比较小的时候，不需要考虑
2)如果机器真的冲突了，可以认为两台或者多台服务器共同保存这条数据
3)在日常业务上，只要不是到万亿级别，都不会冲突
4.物理机在环上分布一定是均匀的吗？
1)哈希函数的均匀性和有少量输入的时候把环均分是两回事
2)使用虚拟节点解决一开始服务器在环上分布不均匀的问题和环上增加或者下线服务器时分布不均匀的问题
3)虚拟节点既能实现负载均衡，也能实现负载管理
5.如何实现顺时针找最近的服务器
1)计算所有服务器的哈希值，生成一个数组[hashcode1,hashcode2,hashcode3]，并且按照哈希值进行从小到大的排序
2)在逻辑端的每一台服务器中都包含该数组
3)前端随机发送一条数据给某台服务器，假设数据计算哈希值是56，如何顺时针找？
相当在有序数组中大于56最左的位置，假设服务器M2计算的哈希值是64，所以找到M2服务器，并且是可以二分查找的，速度很快

#### 虚拟节点实现负载均衡以及负载管理的过程
1.给M1服务器分配1000个字符串，a1 ~ a1000，给M2服务器分配1000个字符串，b1 ~ b1000，给M3服务器分配1000个字符串，c1 ~ c1000，
这是一张路由表。M1服务器中有哪些字符串，可以查找到，哪个字符串属于哪个服务器，也可以查找到。M1、M2、M3都有1000个虚拟节点，互相查找都很方便

2.让M1、M2、M3的1000个虚拟节点抢环上的位置，虚拟节点抢到的数据的实际归属是属于各自的服务器， 环上既没有M1、M2、M3，
环上只放着虚拟节点抢来的数据，M1、M2、M3服务器的1000个虚拟节点都各自抢了环上的三分之一的数据，实现了负载均衡

3.新增M4服务器，分配1000个虚拟节点，当M4的虚拟节点上环之后，1000个虚拟节点会均等的向M1、M2、M3要来一样的数据组成自己的四分之一，
因为哈希函数的均匀性。M1、M2、M3原来各占三分之一，现在M1、M2、M3、M4各占四分之一，那么M1、M2、M3抽出全量的十二分之一数据，
就能组成四分之一，实现数据迁移的均分

4.假设M1服务器性能极高，M2、M3服务器性能平庸，M4服务器性能较差，那么可以给M1分配2500个虚拟节点，给M2和M3总共分配1000个虚拟节点，
给M4分配500个虚拟节点，所以虚拟节点既能实现负载均衡，也能实现负载管理

#### 一致性哈希的总结
一致性哈希可以说是今天所有分布式存储的基础，任何产品只要是一致性哈希，这个东西都会来一遍

