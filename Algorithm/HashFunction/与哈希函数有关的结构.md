### 哈希函数
1）输入参数data，假设是in类型，特征：可能性无穷大，比如str类型的参数
2）输出参数类型out，特征：可能性可以很大，但一定是有穷尽的
3）哈希函数没有任何随机的机制，固定的输入一定是固定的输出
4）输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）
5）再相似的不同输入，得到的输出值，会几乎均匀的分布在out域上
重点：第5条！

#### 经典的哈希函数
1.输入域输出域的数据规模
输入域无穷大，类型：String
输出域相对有限，但也很大，0 ~ 2的64次方-1或者0 ~ 2的128次方-1，类型：int
2.哈希函数不是随机函数，没有任何随机的成分
输入相同，一定导致每次相同的输出
3.输入域无穷大，输出域相对有限，不同的输入导致相同的输出，这种情况叫做哈希碰撞

4.离散性和相同范围的均匀性是一回事，保证均匀分布

#### 哈希函数的推论
f() out输出域范围:0 ~ 2的128次方-1
输入str：利用哈希函数计算出hashcode，再对hashcode % 10
str1  str2  str3  str4
f|    f|    f|    f|
code1 code2 code3 code4
% 10  % 10  % 10  % 10
如果在0 ~ 2的128次方-1 上均匀分布，那么再0 ~ 9的范围上也能均匀分布

#### 哈希函数的作用
可以把数据根据不同值，几乎均匀的分开

举例：
哈希表的设计

#### 哈希表的设计
哈希表有一个初始的桶区域，区域大小17，此时输入key = "abc",value = 25
一、添加
1.计算key = "abc"的hashcode，再对hashcode % 17，假设取模之后的值为5，那么就将"abc"挂载到5号桶中
2.经典的哈希表，桶里是怎么连接的？单链表
3.如果再次输入key = "se"，计算key = "se"的hashcode并且取模%17之后的仍然是5，那么就将"se"挂载到5号桶中"abc"的后面，
组成单链表
4.因为哈希函数有均匀性，所以0 ~ 16一定均匀增长
二、查找
5.因为在哈希函数中，相同的输入一定会导致相同的输出，所以当查询"se"时，计算hashcode并且取模%17，该去哪个桶中查找，
如何查找，通过遍历5号桶的单链表得到。如果查找不到，返回null
三、删除
6.因为在哈希函数中，相同的输入一定会导致相同的输出，所以当删除"se"时，计算hashcode并且取模%17，该去哪个桶中删除，
如何删除，通过遍历5号桶的单链表删除。如果没有查找就无法删除，返回null

7.时间复杂度：O(1)
桶的大小为17，数据长度为N，每个桶的操作就是N / 17，按理说时间复杂度：O(N)，但是有哈希表的扩容操作

8.哈希表的扩容操作：假设桶的大小为17，每个桶的链表长度假设超过7就是比较长了，此时需要进行扩容操作
1)先将痛的大小设置为原来大小的一倍，也就是34，所有桶中的hashcode重新计算，再对hashcode % 现在桶的大小34
2)最后每个桶的链表长度一定为原来链表长度的一半

9.如何证明哈希表的扩容操作的时间复杂度为O(1)
当数据长度为N，每次扩容的次数为logN次，总扩容代价O(N)
桶的大小：2 4 8 16 ... N
扩容代价：2 4 8 16 ... N
哈希表单次的时间复杂度：总扩容代价O(N) / 数据长度N == O(1)

10.哈希表在工程上的改进
桶一般不会扩容，并且原来桶使用的是链表的时候，时间复杂度：O(1)
现在桶使用的是红黑树，时间复杂度：O(1)
所以在工程上哈希表的改进，对于时间复杂度来说，全都无关紧要
工程上的改进都在优化常数时间，对于时间复杂度，都跟经典哈希函数一样
